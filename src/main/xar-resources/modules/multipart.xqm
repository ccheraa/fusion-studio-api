xquery version "3.1";

module namespace mul = "http://evolvedbinary.com/ns/pebble/api/multipart";

declare namespace functx = "http://www.functx.com";

declare
    %private
function functx:trim($arg as xs:string?) as xs:string {
   replace(replace($arg,'\s+$',''),'^\s+','')
};

(:~
 : Extracts parts from a RESTXQ Multipart HTTP Request Body.
 : 
 : @param boundary the multipart boundary
 : @param the entire raw request body.
 : 
 : @return a sequence of Maps, where each map is like:
 :    map {
 :      "headers": (
 :        map {
 :          "name": "Content-Type"
 :          "value": "application/xml"
 :        },
 :        map {
 :          "name": "Content-Disposition"
 :          "value": 'form-data; name="file-upload-1"; filename="hello.xml"'
 :        }
 :      ),
 :      "body": "<hello/>"
 :    }
 :)
declare function mul:extract-parts($boundary as xs:string, $http-request-body as xs:string) as map(xs:string, item()+)* {
    let $raw-parts := mul:parse-parts($boundary, $http-request-body)
    let $parts := $raw-parts ! mul:parse-part(.)
    return
        $parts
};

(:~
 : Given a sequence of parts generated by mul:extract-parts#2, returns only the
 : file upload parts.
 : 
 : @param parts a sequene of parts as generated by mul:extract-parts#2
 : 
 : @return only the parts which are file uploads.
 :)
declare function mul:file-parts($parts as map(xs:string, item()+)*) as map(xs:string, item()+)* {
    for $p in $parts
    return
        for $h in $p?headers
        return
            if ($h?name eq "Content-Disposition" and fn:contains($h?value, 'filename="')) then
                $p
            else()
};


(:~
 : Parses a multipart http request body from a string into
 : a sequence of strings, each string is a body part.
 : 
 : @param boundary the multipart boundary
 : @param s the http request body string to parse
 : 
 : @return a sequence of strings one for each part.
 :)
declare
    %private
function mul:parse-parts($boundary as xs:string, $s as xs:string?) as xs:string* {
  if($s) then
    let $tail := fn:substring-after($s, '--' || $boundary || '&#xD;&#xA;')
    let $head := fn:substring-before($tail, '&#xD;&#xA;' || '--' || $boundary)
    let $head := if($head) then $head else ()  (: avoids empty string results :)
    return
      ($head, mul:parse-parts($boundary, $tail))
  else ()
};

(:~
 : Parses a multipart part from a string into
 : a sequence of maps, each map holds the headers and body
 : of the part.
 : 
 : @param part the raw string of a multipart part
 : 
 : @return a map.
 :)
declare
    %private
function mul:parse-part($part as xs:string) as map(xs:string, item()) {
    let $headers-strings := fn:tokenize(fn:substring-before($part, '&#xD;&#xA;&#xD;&#xA;'), "&#xD;&#xA;")
    let $body-string := fn:substring-after($part, '&#xD;&#xA;&#xD;&#xA;')
    return
        map {
            "headers": mul:parse-headers($headers-strings),
            "body": $body-string
        }
};

(:~
 : Parses the headers from a multuipart part.
 : 
 : @param headers the headers, each as a string "name: value"
 : 
 : @return a sequence of maps, one for each header.
 :)
declare
    %private
function mul:parse-headers($headers as xs:string*) as map(xs:string, xs:string)* {
  for $header in $headers
  return
    map {
        "name": fn:substring-before($header, ": "),
        "value": fn:substring-after($header, ": ")
    }
};
